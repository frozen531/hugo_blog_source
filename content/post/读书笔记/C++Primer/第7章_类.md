---
title: "第7章 类"
date: 2023-03-05T21:20:56+08:00
draft: true
tags: ["C++Primer"]
categories: ["读书笔记"]
---


 类

类是一种自定义的类型，通过**数据抽象**和**封装**，将**接口**（对外提供的功能函数）和**实现**（包括数据成员、负责接口实现的函数体以及类的一些私有函数）分离。

上面只是人为的划分开需要对外部提供和隐藏的成员，语言设计上，通过访问<font color = "blue"><strong>访问说明符</strong></font>强制性的封装隐藏。

**封装的好处**：

1. 代码模块化，高内聚，低耦合
2. 可以防止用户无意间修改类中数据
3. 被封装的类接口实现可以随意更改，而无须调整调用者代码

## 1.类的组成和相关函数说明

- 数据成员
- 成员函数 ： 提供对外的类功能接口
- 私有成员函数 ： 
- 辅助函数 ： 作为成员函数的实现部分，实际上不属于类本身
---
- 类型成员 ： 使用```typedef```或```using```定义，存在访问限制

### 🌂 1.1 数据成员
#### 1.1.1 类成员编译过程
两步走：
- 先所有成员的声明（整个类定义的内容```class Name{};```）
- 再成员函数体（函数的具体实现）

因此在函数体内不必在意成员出现的顺序，它们都已经记录在册了。

但是要注意的是有一类<font color="blue">**类型成员，必须先定义后使用**</font>。因为在声明过程中需要类型，编译时，对应的类型必须能找到才可通过，所以有上述规定。


#### 1.1.2 类中数据成员初始化
三种方法：
- 类内初始值 ： 声明数据成员时，给定初值，使用“=”或“{}”
- 构造函数初始化列表
- 没有上述两种的进行默认初始化，这里内置类型和复合类型会出现未定义

#### 1.1.3 const和mutable

🔸 ```const```

```const```数据成员需要进行类内初始化或构造函数初始化列表赋值

🔸 ```mutable```

```mutable```修饰的成员变量在常量成员函数中也是可以修改的。

#### 1.1.4 类的静态成员
- ```static```只能在类内声明时使用
- 静态成员不与对象绑定在一起
- 静态成员函数中没有```this```指针，因此函数内部不能使用类的非静态成员，并且静态成员函数不能声明为```const```，因为```const```是针对```this```指向的对象的限制
- 静态成员函数可以定义在类内，也可以定义在类外，类外定义时不能加关键字```static```
- 调用时可以使用如下方式：

```cpp
类名::静态成员
类对象.静态成员
类对象->静态成员
```

- 静态数据成员为确保只定义一次，将其<font color = “blue”><strong>定义在cpp文件中</strong></font>。如果定义在```.h```文件中，则多次对头文件的```include```会导致重定义问题
- 静态成员可以是不完整类型，同时也可以作为参数的默认实参


### 🌂 1.2 函数

#### 1.2.1 成员函数```this```理解

类的成员函数是如何准确调用类对象的数据成员？

- 类对象通过**成员访问运算符**调用成员函数时，由编译器负责传入<font color = “blue”><strong>隐式形参```this```</strong></font>。
- ```this```是一个**指针常量**，其指向的地址不可以修改，类型是<font color = “blue”><strong>类名 ```*const```</strong></font>。

#### 1.2.2 常量成员函数

```cpp
class Name
{
    const Name& func() const;
}
```

- 所谓的常量成员函数，是通过```const```对```this```进行限定，将其类型修改为<font color = “blue”><strong>```const 类名 * const```</strong></font>
- 这也是为什么我们在常量成员函数中不能够修改数据成员的原因，此时的```this```不仅指向的地址不能修改，就连地址中指向的内容也无法修改。<br>

**常量成员函数返回类引用时的区别**：<br>

- 非常量的成员函数返回的```this```是指向一个非常量的对象
- 常量成员函数返回的```this```是指向一个常量对象

```cpp
class Name
{
    Name& func() {...; return *this;}
    const Name& func() const {...; return *this;}
}
```

#### 1.2.3 辅助函数

- 辅助函数是类的非成员函数。这些函数是类接口的组成部分。
- <font color = “blue”><strong>辅助函数的声明应该与类在同一个头文件中，定义要在cpp文件中，否则会出现“重定义”的错误</strong></font>。

```cpp
class Name
{
    // 如果辅助函数要访问类中私有成员，可以设为友元函数
};

// 辅助函数的声明
void func();
```


#### 1.2.4 inline函数
参考链接：[cpp中内联函数的优点与缺点](http://blog.sina.com.cn/s/blog_4a0e545d01000c4e.html)<br>

🔸 内联函数是为了**提高性能**而设立的。内联函数的实现有以下3种：
- 类内定义的函数：是隐式的内联函数
- 类内声明时：加关键字```inline```
- 类外定义时：加关键字```inline```
> 1. 不光成员函数可以内联，非成员函数也可以；
> 2. 虽然在写代码的时候，可以我们自己设定内联函数，但是能否成为内联函数，由编译器决定。

🔸 **优点**：<br>

1. 内联函数是在编译时，在函数调用处展开，减少函数调用```call```带来的开销，包括栈帧开辟和回收，参数入栈，寄存器保护与恢复等。
2. 由于在调用处展开，所以编译器可以结合上下的代码对其进行优化

🔸 **函数体代码何去何从**：<br>

- 由于编译器在编译时通常以一个```cpp```文件为一个编译单元，在此过程中，预处理器会展开```#include```的头文件内容，同时编译器在编译时也会对内联函数在其调用处替换为函数体。<br>
- 由于编译时不会涉及其他的```cpp```文件，只会有```h```头文件中的内容，所以为了保证内联函数在多个编译单元处展开的代码一致性，以及可以找到函数体，<font color = “blue”><strong>内联函数必须声明并定义在h头文件中</strong></font>。

🔸 **内联区别于宏**：
- 宏展开：预处理器行为，是由预处理器负责，不能对类型进行检查
- 内联：编译期行为，由编译器负责，会对类型进行检查

### 🌂 1.3 类型成员
类型成员是在类中使用```typedef```或```using```定义的类型

- 类外使用时要加域名
- 作为类中成员，存在访问限制。

```cpp
class Name
{
public:
    typedef std::string::size_type pos;
    // 等价于
    using pos = std::string::size_type;
}
```
**区别于其他成员**：

- <font color = red>**通常定义于类开头处**</font>
- 必须先定义后使用，因为类型成员通常用于声明变量，在编译整个类定义时，编译器会向上查找声明


## 2. 类作用域与名字查找
<font color = “blue”><strong>每一个类都是一个作用域</strong></font>。

### 🌂 2.1 类外定义成员
在类外定义这些成员时，要加上**类名加::**

```cpp
SaleDate& SaleDate::combine(const SaleDate&)
{ ... }
```

- 函数名之前加上```SaleDate::```后，后面的函数参数和函数体都在这个作用域下。
- 如果函数返回值也是在这个作用域下定义的成员，由于返回值不包括在该作用域下，所以需要自己加上作用域。

### 🌂 2.2 不完全类型
<font color = "blue"><strong>前向声明是指只声明却没有定义</strong></font>。向程序中引入类的名字，指明其是一种<font color = "blue"><strong>类类型</strong></font>。

```cpp
class Screen;
```

- 对于```Screen```来说，声明之后定义之前是一个<font color = "blue"><strong>不完全类型</strong></font>。不完全类型由于没有定义，所以并不知道该类型需要多大的内存，所以不能够定义该种类型的对象。
- <font color = "blue"><strong>只有等类定义完整，才能定义其对象</strong></font>。
- 不完全类型的使用情景：
> 1. 可以指定这种类型的指针或引用
> 2.  声明（但是不能定义）以不完全类型为参数或返回值的函数

```cpp
class Node
{
    int val;  // int作为内置类型，已经被定义过了，所以可以定义对象
    Node* next; // 不完全类型的使用
}
```

### 🌂 2.3 名字查找
🔸 **普通变量**，包含成员函数声明中的参数和返回值：
- 首先，在名字所在的块中寻找，**只能在块中位置以上寻找**
- 其次，外层作用域找，也是向上

🔸 **定义在类内部的成员函数内**用的名字：

- 首先，编译所有成员的声明，这里的声明中参数和返回值的类型按照普通名字寻找
- 直到类全部可见后才编译函数体，可以使用类中的成员

🔸 如果**成员函数定义在类外部，则内部实现时**要考虑：
- 类定义前全局作用域下的声明
- 类定义后，成员函数定义前的全局作用域下的声明

```cpp
// 类定义前的全局作用域下的声明
...

// 类定义
class Name
{
    void func();
};

// 类定义后，成员函数定义前的全局作用域下的声明
...

// 成员函数定义
void Name::func(){}
```

- 变量名在块内外可以同名，如果想指定的话：

```cpp
// 使用类的成员
this->
类名:: 

// 全局作用域
::
```

- 类型成员名在块内外不可同名

## 3. 构造函数
无论何时，只要创建对象就需要调用构造函数。

🔸 **特点**：
- 无返回值
- 不能被声明成```const```
> 因为构造函数通常需要为成员变量初始化或赋值，若加上```const```，表示```this```指向的对象内容不可修改，违背了构造函数的初衷
- 可重载

🔸 **什么情况下适合编译器生成的默认构造函数**：
- 只有类没有提供任何构造函数时，编译器才能生成合成默认构造函数
- 只有类中的**内置类型**和**复合类型**都有类内初始值时，才能使用默认构造函数，否则会造成后续代码出现运行时不知道为什么的错误

有些情况下，编译器是无法生成默认构造函数的，详细见13章介绍。

🔸 **什么情况下必须使用初始化列表**：

- 类有```const```、引用成员时必须将其初始化
- 成员中有类类型，且该类没有定义默认构造函数时，必须将该成员初始化

### 🌂 3.1 构造函数初始化过程

```cpp
Name()
// 成员在构造函数体之前执行默认初始化
{
    // 这里是赋值
}
```

**成员初始化顺序**：
- 成员初始化的顺序与其在类中定义的顺序一致
- 最好用构造函数的参数作为成员的初始值
> 否则成员变量间的相互赋值可能会因为成员变量初始化顺序导致失败

### 🌂 3.2 默认构造函数
- 编译器提供的是合成的默认构造函数，我们如果想写一个一样的，可以使用```default```。

```cpp
Name() = default; // 默认构造
```

- 构造函数中参数都提供了默认实参的构造函数也称为是默认构造函数

```cpp
Name(string s = "") {} // 默认构造
```

- 实际中，<font color = "blue"><strong>如果定义了其他的构造函数，那么最好也提供一个默认构造函数</strong></font>，可以使用上面两种方法
> 否则编译器将不会提供默认构造函数，可能导致以该类作为类成员的类，如果进行默认初始化，必定会失败。

### 🌂 3.3 隐式类型转换和explicit

#### 3.3.1 隐式类型转换

如果**构造函数只接受一个实参**，则它相当于定义了转换为此类型的隐式转换机制。

<font color = "blue"><strong>编译器只会自动执行一步类型转换</strong></font>，所以类类型转换不总是有效的。

```cpp
// 隐式类型转换 char* -> string 一步转换成功
string("999-999-999"); 

// 需要(1)char* -> string (2) string -> Name两步转换，失败
Name("999-999-999"); 
```

#### 3.3.2 explicit

- ```explicit```只对一个实参的构造函数有效
- ```explicit```只能在类内声明时使用

```cpp
explicit Name(string s = "") {}
```

- 使用了```explicit```的构造函数不能够进行隐式类型转换，需要强制类型转换（显示转换）。

```cpp
static_cast<Name>("999-999-999");
```

- ```explicit```构造函数只能用于直接初始化（"```=```"初始化变量是拷贝初始化；其他是直接初始化）


## 4. 友元
通过**访问说明符**强制限定后，非类内函数或其他类想使用类中的成员时，需要通过设置友元```friend```。

需要注意的是：
1. <font color = "blue"><strong>类中的友元声明仅仅是指定了访问权限，而并非通常意义上的声明，因此必须提供独立的声明后才能调用该友元</strong></font>。
2. 友元并非类的成员，它仅是声明，因此<font color = "blue"><strong>不会受到访问说明符权限的限制</strong></font>，但通常集中放于类的开头或结尾处。
3. 友元关系是单方向的，不具有传递性，类中声明友元，<font color = "blue"><strong>只能说明该类承认与所声明方的友元关系</strong></font>，对方可以使用自己的私有成员，但是该类不能使用对方的私有成员。
4. <font color = "blue"><strong>类和非成员函数的声明不是必须在他们的友元声明之前</strong></font>。

### 🌂 4.1 辅助函数友元化

- 辅助函数的友元声明指定该辅助函数的访问权限，还需要提供该辅助函数真正意义上的声明

```cpp
class X
{
    friend void f(); // 友元声明
    void g(); // 成员函数
    void h() { f(); } // 错误：编译器向上找不到f()的声明
    void b();
};

void X::g() { f(); } // 错误：编译器向上找不到f()的声明

void f() {} // 友元函数的定义

void X::b() { f(); } // 正确的函数定义

```

### 🌂 4.2 友元类
```Screen.h```

```cpp
class Screen
{
    friend class Win_mgr; // Screen承认与Win_mgr的友元关系，Win_mgr可以使用Screen中的私有成员
};
```

```Win_mgr.h```

```cpp
#include "screen.h"
class Win_mgr
{
    // Win_mgr可以使用Screen中的私有成员
};
```
分析：
- 在```Screen.h```中并没有```#include "Win_mgr.h"```，仅仅是友元声明，这时还没有```Win_mgr```类的声明。
- 在```Win_mgr.h```中因为要用到```Screen.h```中的私有成员，一定需要包含类```Screen```的定义内容，所以要```#include "Screen.h"```。这时预处理器会将```Screen.h```展开，这时在```Win_mgr.h```中既有了友元声明，又有了类```Win_mgr```的声明和定义


### 🌂 4.3 成员函数友元化