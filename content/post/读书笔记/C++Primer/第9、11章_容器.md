---
title: "第9、10章 容器"
date: 2023-03-05T21:20:58+08:00
draft: true
tags: ["C++Primer"]
categories: ["读书笔记"]
---


## 1. 容器

容器是一些**特定类型对象**的集合。

- 顺序容器：元素的位置与其加入容器的顺序相对应
- 关联容器：元素的位置与元素相关联的关键字决定

## 2. 顺序容器

顺序容器的特性：<font color = "blue"><strong>可以快速顺序访问容器</strong></font>

| 类型         | 名称                     | 元素访问         | 添加删除                               | 存储空间是否连续 |
| ------------ | ------------------------ | ---------------- | -------------------------------------- | ---------------- |
| ```vector```       | 可变大小数组             | 快速随机访问     | 在尾部之外的位置插入或删除元素可能很慢 | 是               |
| ```deque```        | 双端队列                 | 快速随机访问     | 在头尾位置插入删除元素很快             | 分段连续         |
| ```list```         | 双向链表                 | 支持双向顺序访问 | 任何位置插入删除都很快                 | 否               |
| ```forward_list``` | 单向链表                 | 支持单向顺序访问 | 任何位置插入删除都很快                 | 否               |
| ```array```        | 固定大小数组             | 快速随机访问     | 不能删除或添加元素                     | 是               |
| ```string```       | 类似```vector```，专门保存字符 | 快速随机访问     | 在尾部插入删除元素快                   | 是               |

**容器的选择**：
- 取决于访问元素和插入删除哪个占主导地位
- 通常```vector```是首选
- 不确定时尽量选用```vector```和```list```的共有操作，尽量使用迭代器而不是下标访问，这样可以方便选择其中之一

```array```与内置数组的区别：
- 内置数组对象间不允许拷贝和赋值，只能一个元素一个元素的拷贝赋值
- ```array```可以直接去初始化另一个```array```

### 🚩 2.1 容器通用操作

#### 2.1.1 类型别名(typedef)

| 类型别名        | 说明             | 使用                |
| --------------- | ---------------- | ------------------- |
| ```value_type```      | 元素类型         | 同下                |
| ```reference```       | 元素的左值引用   | 同下                |
| ```difference_type``` | 两个迭代器间距离 | 同下                |
| ```iterator```        | 迭代器类型       | ```list<int>::iterator``` |

```::```作用域运算符

#### 2.1.2 迭代器

迭代器范围：<font color = "blue"><strong>左闭右开</strong></font>

```cpp
c.begin(), c.end()
c.cbegin(), c.cend()
c.rbegin(), c.rend()
c.crbegin(), c.crend()
```

#### 2.1.3 容器初始化

| 类型                  | 说明                                           |
| --------------------- | ---------------------------------------------- |
| ```C c1(c2)```              | 两个容器类型必须相同                           |
| ```C c(b, e) ```            | ```b```和```e```为迭代器，两个迭代器范围内元素的拷贝，类型只要能转化即可 |
| ```C c(n)``` <br> ```C c(n, t)``` | ```n```指定元素个数                                  |

**注意**：
- 只有顺序容器可以接收大小这个参数
- 如果元素类型为内置类型或有默认构造函数的类类型才可以采用```C c(n)```；没有默认构造函数的类类型必须显示提供元素初始值```C c(n, t)```

#### 2.1.4赋值与swap???

- 赋值相关运算会导致左边容器内部的迭代器、引用和指针失效。
- ```swap```将容器中内容交换，不会导致指向容器的迭代器、引用和指针失效.(```array```与```string```除外)

#### 2.1.5 添加元素

| 操作                                                         | 说明                                                         | 插入的元素来源 | 返回值             |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ------------------ |
| ```c.insert(p, t)``` <br> ```c.insert(p, n, t)``` <br> ```c.insert(p, b, e)``` | 在p指向的元素之前插入一个值为t的元素 <br> 在p指向的元素之前插入n个一个值为t的元素 <br> 在p指向的元素之前插入b到e之间的元素 | 拷贝     | 插入元素当前的位置 |
| ```c.emplace(p, args) ```                                          | 在p指向的元素之前插入一个值为t的元素                         | 构造     | 插入元素当前的位置 |

#### 2.1.6 访问元素

- 迭代器访问元素，需要解引用使用
- ```front()```和```back()```返回引用，需要注意对空容器调用，会产生和下标越界一样的运行错误
- ```.at()```和下标也要注意越界问题

<font color = "blue"><strong>程序员需要保证下标有效</strong></font>

#### 2.1.7 删除元素

| 操作        | 说明               | 返回值                     | 扩展                                                    |
| ----------- | ------------------ | -------------------------- | ------------------------------------------------------- |
| ```erase(iter)``` | 删除```iter```指向的元素 | 删除后的下一个位置的迭代器 | ```pop_back()``` <br> ```pop_front()``` <br> ```clear()``` <br> ```remove(T)``` |

<font color = "blue"><strong>插入和删除元素可能会导致原来的迭代器失效，所以需要重新定位</strong></font>

```cpp
list<int> lst = {1,2,3,4,5,5};
auto itb = lst.begin();
auto ite = lst.end();
while(itb != ite) // 错误，因为删除导致end的定位失效，所以需要重新定位
    if(*itb % 2) itb = lst.erase(itb);
    else ++tib;
```

修改为：

```cpp
list<int> lst = {1,2,3,4,5,5};
auto itb = lst.begin();
while(itb != lst.end()) // 重新定位
    if(*itb % 2) itb = lst.erase(itb);
    else ++tib;
```

### 🚩 2.2 vector的扩展

以两倍于原来内存大小扩展

### 🚩 2.3 string的额外操作

| 操作                          | 说明                                                    | 返回                                                         |
| ----------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| ```s.substr(pos, n) ```             | 从```pos```的位置，拷贝长度为```n```的子串                          | ```string```类型子串                                               |
| ```s.replace(range, args) ```       | 删除```range```范围内元素，替换为```args```指定的字符               | 修改了```s```                                                      |
| ```s.find(str, pos)```              | 从```pos```(默认为0)位置处搜索```str```出现的位置                   | ```std::string::size_type```类型的值，表示匹配下标的位置 <br> ```std::string::npos```表示没找到 |
| ```s.find_first_of(str, pos)```     | 从```pos```(默认为0)位置处搜索```str```中人一个字符第一次出现的位置 | 同上                                                         |
| ```s.find_first_not_of(str, pos)``` | 从```pos```(默认为0)位置处搜索不在```str```中的字符首次出现的位置   | 同上                                                         |
| ```s = to_string(arg)```            | 整数转字符串                                            |                                                              |
| ```stoi``` <br> ```stol```                | 字符串转整数                                            |                                                              |
| ```atoi``` <br> ```atol```                | ```char*```转整数                                             |                                                              |

### 🚩 2.4 容器适配器

| 类型           | 名称   | 操作                              |
| -------------- | ------ | --------------------------------- |
| ```stack```          | 栈     | ```.top()``` <br> ```.push()``` <br> ```.pop()```   |
| ```queue```          | 队列   | ```.front()``` <br> ```.push()``` <br> ```.pop()``` |
| ```priority_queue``` | 大根堆 | ```.top()``` <br> ```.push()``` <br> ```.pop()```   |

## 3. 关联容器

关联容器支持高效的查找与访问。

### 🚩 3.1 map

不论是```map```还是```unordered_map```，都支持下标访问，但需要注意的是：<font color="red">**当关键字不存在于容器中时，会创建并对关联值进行值初始化**</font>。

关键字 - 值 ： ```{key, data}```

```cpp
pair<string, int>("author", 5);
```

#### 3.1.1 操作

| 操作       | 说明                                                 |
| ---------- | ---------------------------------------------------- |
| ```c.find(k)```  | 查找关键字k，返回对应的迭代器；若不存在，则返回```end()``` |
| ```c.count(k)``` | 判断关键字k是否存在于容器中，不存在，返回0           |



### 🚩 3.2 set

因为```set```的```key```就是```data```，所以```set```的迭代器也是```const```类型的