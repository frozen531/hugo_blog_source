---
title: "03_程序的机器级表示"
date: 2023-07-29T15:59:22+08:00
draft: true
tags: ["深入理解计算机系统"]
categories: ["读书笔记"]
---

## 0. 前言

我们平时编程使用的是高级语言，这些高级语言经编译器编译成遵循目标机器指令集的汇编语言，汇编语言是机器代码的文本表示，所谓的机器代码即0和1的二进制程序。

阅读和理解汇编语言的好处在于：
1. 理解编译器的优化能力，分析程序中低效率代码，优化代码，提高程序运行效率；
2. 了解程序在运行时的行为，如多线程如何做到数据共享和保持数据私有等；
3. 了解和防御程序漏洞，如缓冲器溢出等

Intel系列处理器俗称x86，指代整个32位微处理器系列，从i386开始直到Pentium4。\
x86-64是指支持64位扩展，从Pentium4E开始，并引入超线程、多核等。\
每个处理器设计都是向后兼容。

由于这章涉及到了汇编语言，笔记中关于8086CPU指令的描述摘自王爽老师的《汇编语言》。

### 查看汇编文件

```bash
gcc -Og -o target p1.c p2.c
```

已知源文件经过编译器生成可执行文件target，编译过程中会按照指定的优化等级对源代码进行优化。过高等级的优化会使代码严重变形，不易理解。`-O1`和`-O2`是较好的选择。[gcc -O0 -O1 -O2 -O3 -Os 编译优化等级](https://blog.csdn.net/lyndon_li/article/details/123671102)

- -g ：生成调试信息
- -Og ：告诉编译器生成符合原始C代码结构的机器代码，
- -O0 ：最少的优化，此为编译器默认选项
- -O 或 -O1 ：有限优化
- -O2 ：高度优化
- -Os ：在O2的基础性优化，但不缩减代码尺寸
- -O3 ：最大程度优化

有两种方式可以查看汇编代码，两者的结果会有细微差别，例如表示大小指示符的后缀q，`movq`和`mov`、`retq`和`ret`，这些后缀通常省略是没有问题的。

1. `gcc -S`可生成汇编程序p1.s
2. `objdump -d`反汇编(disassemlber)目标文件

### 汇编代码格式

汇编代码格式有两种：ATT格式和Intel格式。对比如下两段汇编代码：

- ATT

```
pushq %rbx
movq %rdx, %rbx
call mult2
movq %rax, (%rbx)
popq %rbx
ret
```

- Intel

```
push rbx
mov rdx, rbx
call mult2
mov QWORD PTR [rbx], rax
pop rbx
ret
```

在如下方面有所不同，通过下面表述可知学习8086汇编语言时使用的是Intel格式，本书中x86-64使用ATT格式。

1. Intel格式省略了指示大小的后缀，使用mov而非movq；
2. Intel格式省略了%，使用rbx而非%rbx；
3. 使用不同方式描述内存中位置，QWORD PTR [rbx]而非(%rbx)；
4. 带多操作数的情况下，操作数顺序相反。如mov指令。


## 1. 数据表示及处理

程序=数据结构+算法。这里面都涉及到数据的表示、存放与处理。

### 数据访问

对于数据访问需要知道两点：数据位置和数据尺寸：
- 数据可以存放在内存和寄存器中
- 数据尺寸根据处理器位数不同可以有byte、word、double word等。

#### 8086CPU指令

8086CPU是16位处理器，有**14**个16位寄存器，包括：
- 通用寄存器：`AX BX CX DX`，可拆分程高8位和低8位使用，如`AH，AL` 
- 指令执行相关：`CS:IP`
- 栈相关：`SS:SP`
- 段寄存器：`DS`（数据段） `CS`（代码段） `SS`（栈段） `ES`（附加段），通过`段地址x16+偏移地址`，实现20位地址总线的寻址范围。
- 其他内存寻址寄存器：`SI DI BP`，注意此处的内存寻址以下下搭配是合法的，当包含`BP`时，默认段地址是`SS`。
> 0. 直接寻址：`[idata]`
> 1. 寄存器间接寻址：`[SI] [DI] [BX] [BP] `
> 2. 寄存器相对寻址：`[BX+idata] [BP+idata] [SI+idata] [DI+idata]`
> 3. 基址变址寻址：`[BX+SI] [BX+DI] [BP+SI] [BP+DI]`
> 4. 相对基址变址寻址`[BX+SI+idata] [BX+DI+idata] [BP+SI+idata] [BP+DI+idata]`
- 标志寄存器又称程序状态字：`PSW`。该寄存器按位起作用。

![PSW状态字内容.png](深入理解计算机系统/PSW状态字内容.png)

> ZF：零标志位，记录执行指令后结果是否为0 \
> PF：奇偶标志位，记录指令执行后，所有bit位中1的个数是否为偶数 \
> SF：符号标志位，记录执行指令后，结果是否为负。对于有符号数计算，可以通过SF判断结果正负；对于无符号数运算没有意义 \
> CF：进位标志位，一般来说，对于无符号数运算，记录运算结果的最高有效位向更高位的进位值，或从更高位的借位值 \
> OF：溢出标志位，在进行有符号数运算时，如果超出了表示范围称为溢出 \
> DF：方向标志位，在串处理指令`movsb`、`movsw`中，控制每次操作后`si`、`di`的增减。`cld`将`df`置位`0`，`std`将`df`位置`1` \
> TF：单步中断标志位，值为1，则产生单步中断，引发中断过程。  \
> IF：中断允许标志位，正对可屏蔽中断，值为1，可处理可屏蔽中断，否则不处理。`cli`置0，`sti`置1 



8086中可以处理两种尺寸的数据，byte和word。两种方法指定数据尺寸。
- 通过寄存器指明

```bash
#word操作
mov ax, 1   # (ax)=1
mov bx, ds:[0]

#byte操作
mov al, 1   
mov bl, ds:[0]
```

- 没有寄存器名的情况下，用操作符`X ptr`指明内存单元的长度

```bash
#word操作
mov byte ptr ds:[0], 1
inc byte ptr [bx]

#byte操作
mov word ptr ds:[0], 1
inc word ptr [bx]
```

#### x86-64

x86-64位系统可以表示并处理8~64bit（1~8byte）的数据，数据类型表示如下：

C声明 | Inter数据类型 | 汇编代码后缀 | 大小(字节)
---|---|---|---
char | 字节 | b（byte） | 1
short | 字 | w（word） | 2
int | 双字 | l（double words） | 4
long | 四字 | q（quard words） | 8
char* | 四字 | q（quard words） | 8
float | 单精度 | s（single float） | 4
double | 双精度 | l（double float） | 8

汇编代码中通过增加上述后缀来指明处理数据的长度，如上例中的`movq`处理8字节数据。注意：浮点数的表示和计算用完全不同的指令和寄存器。

64位整数寄存器有如下16个，均可拆成32、16、8位寄存器使用。

![x86-64整数寄存器.png](深入理解计算机系统/x86-64整数寄存器.png)

对于低字节使用规则：

1. 生成1字节和2字节数字的指令会保持剩下的字节不变
2. 生成4字节数字的指令会把高位4字节置0

在内存寻址上，增加了比例变址寻址。

> 比例变址寻址：`Imm(rb, ri, s)`：一个立即数偏移Imm，一个机制寄存器rb，一个编制寄存器ri和一个比例因子s（bixushi 1\2\4\8）。有效地址计算为`M[Imm+R[rb]+R[ri]*s]`。

### 基础指令

指令集中包含有众多指令，下面列举常用指令。

#### 数据传送指令

根据操作的数据大小不同，通过增加后缀，指明数据尺寸。

- 当有一个操作数为寄存器，另一个为内存或立即数时，mov通常指明目的寄存器对应数据大小
- 当目的和源都是寄存器时，允许进行目的到源的字长扩展，会涉及到有符号和无符号数扩展
```bash
# 单个寄存器操作数
movb $0xAA, %dl # %dl=0xAA

# 零扩展数据传送指令
movzbq %dl, %rax

#符号扩展数据传送指令
movsbq %dl, %rax
```

需要注意：
1. x86-64中，传送指令的两个操作室不能都指向内存位置。
2. 当执行强制类型转换既涉及大小变化又涉及符号变化是，操作影响改变大小。

#### 入栈出栈指令

加后缀指明操作数尺寸，注意尺寸与寄存器大小间的匹配

```
pushq %rbx
popq %rbx
```

#### 获取有效地址指令

加后缀指明操作数尺寸，注意尺寸与寄存器大小间的匹配 \
除了取有效地址外还可以进行一些计算
``` bash
# %rax = %rdi + 4 * %rsi
leaq (%rdi, %rsi, 4) %rax 
```

#### 算数/逻辑/移位指令

列举基础整数算术操作，通过增加后缀指定操作数尺寸

- 一元操作

```bash
inc D # 加一操作 D = D + 1
dec D # 减一操作 D = D 1 1
neg D # 取负操作 D = -D
not D # 取补操作 D = ~D
```

- 二元操作

```bash
add s, d #加 d = s + d
sub s, d #减 d = s - d
imul s, d #承 d = s *+* d
xor s, d #异或 d = s ^ d
or s, d #或 d = s | d
and s, d #与 d = s & d
```

- 移位

```bash
sal k, d #左移 d = d << k
shl k, d #左移 等价于 sal
sar k, d #算数右移 d = d >>A k
shr k, d #逻辑右移 d = d <<L k
```

#### 特殊的算术操作

指两个64位操作数做乘法，结果位128位，称为八字(oct word)。操作类似8086CPU中的乘/除法，使用AX和DX两个寄存器存储操作数和结果。

## 2. 程序的流程控制

程序设计基本结构：顺序、选择和循环。顺序结构是指按照程序指令出现的顺序执行直至结束，称为直线代码行为。选择和循环都涉及到条件判断。

### 条件码访问及使用

#### 条件码
**测试数据值**是实现条件判断常见的方法。同8086一样，x86-64也拥有程序状态寄存器，本书中称`CF`（无符号溢出）、`ZF`（零）、`SF`（负数）、`OF`（有符号溢出）为条件码。以下两种方式可修改条件码：

1. 上面所有的**整数算法操作**都会修改条件码，同时会改变参与计算的寄存器值；
2. `CMP`和`TEST`指令，修改条件码，但不改变参与的寄存器值。同过增加后缀操作不同尺寸的数值，如：`cmpw`比较字节等；
> `CMP S1 S2`，等同于`SUB S1 S2`，比较两者大小`S2-S1` \
> `TEST S1 S2`，等同于`AND S1 S2`，测试两者值，常见`test S S`，判断值S是正数、负数或0；或一个擦作数为掩码，知识哪些位应该被测试。

#### 访问条件码

x86-64提供了访问条件码的指令。常见使用条件码的三种方法：
1. 根据条件码，将**单字节**寄存器或内存置0或1。例如C语言中的三目表达式：`int ret = a > b ? 1 : 0`。汇编指令为`set D`，添加后缀，代表条件码的组合。根据使用对象不同，可划分为三组后缀：
> - a. 有符号/无符号均可使用：`e(equal)`、`z(zero)`、`n(not)`，例如：`sete D`判断`ZF`是否为0，是，D置1，否置0。同`setnz D`。
> - b. 有符号数：`s(sign)`、`g(greater)`、`l(less)`，例如：`setng`表示不大于，`sets`表示负数。
> - c. 无符号数：`a(above)`、`b(below)`，例如：`setna`表示不大于

2. 根据条件码跳转执行，`jmp label`无条件跳转到标号位置处执行。接后缀表示条件判断，后缀使用方法同上。如：`jz L1`，相等跳转到L1处。jmp涉及到一个绝对位置和相对位置跳转，标号会被替换成相应的值。
3. 可以有条件的传送数据（未介绍）。

### 选择结构

在编译过程中，编译器会对代码进行优化处理，形式如C语言描述（汇编语言的直译），常用以`!t`判断，也可以判断`t`。

#### if-else

```c
// C语言
if(test-expr)
    then-statement
else
    else-statement

// C语言描述
    t=test-expr;
    if(!t)
        goto false;
    then-statement
    goto done;
false:
    else-statement
done:
```

#### if-else if-else

如上多嵌套。

#### switch

当分支众多（例如4个以上）时，会构建一个跳转表（数组），在跳转表中记录各个值对应的标号地址进行跳转。好处在于：执行判断语句的时间与判断个数无关。

```c
switch(a)
{
    case -2:    // L2标号，代表跳转地址
    case 0:    // L4
    case 1:     // L5
        break;
    case 3:    // L6
        break;
    default:    // L3
}
```

编译器会将分支映射入跳转表中，当测试值进入后，会计算其执行路径对应的下标值，直接跳转进入。\
注意：
1. 数组下标从0开，但是测试值是任意整数，编译器会将其做一个偏移，移入0及其以上，所以偏移计算是a+=2；
2. 数组下标是连续的，所以对于case中没有提到的值，进入defalut分支。所以数组中值如下：
```c
static void* jt[6] = {L2, L3, L4, L5, L3, L6};
```
### 循环结构

#### do...while

```c
// C语言
do
    body-statement
while(test-expr);

// C语言描述
loop:
    body-statement
    t=test-expr;
    if(t)
        goto loop;
```

#### while

```c
// C语言
while(test-expr)
    body-statement

// C语言描述:方式一：跳转到中间(jump to middile)
    goto test;
loop:
    body-statement
test:
    t=test-expr;
    if(t)
        goto loop;

// C语言描述:方式二：guarded-do，转成do-while形式
    t=test-expr;
    if(!t)
        goto done;
loop:
    body-statement
    t=test-expr;
    if(t)
        goto loop;
```

#### for

```c
// C语言
for(init-expr; test-expr; update-expr)
    body-statement

// 转成while，其最后的汇编形式同while
init-expr;
while(test-expr)
{
    body-statement
    update-expr;
}
```

## 3. 过程描述-运行栈

函数调用使用了栈提供的先进后出的机制。在内存空间中，栈的增长方向是从高到低。栈指针减少适当的量可以为局部变量在栈上分配内存，栈指针增加，可以用来释放内存。

实际上，许多函数不需要栈帧，当所有局部变量都可以保存到寄存器中，而且该函数不会调用其他函数时，就可以这样处理。

![栈帧.png](深入理解计算机系统/栈帧.png)

- 数据传送

> 1. 入参通过寄存器或栈传送。x86-64中，当函数参数个数多于6个时，使用栈传送。用来传送参数的寄存器有：`%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`\
> 2. 返回值存放在`%rax`中

- 局部变量

寄存器`%rbx`、`%rbp`、和`%r12~%r15`可用来存放局部变量，如果函数栈中使用这些寄存器，那么被使用的寄存器需要保存到栈中，如图被保存的寄存器部分。有些局部变量必须保存到栈中，如：
> 1. 寄存器数量不足以存放所有的局部变量；
> 2. 对一个局部变量使用&取地址，由于需要取到地址，所以该局部变量必须在栈中；
> 3. 数组或联合体


做如下举例，明确内存中栈帧存放位置。
```c
long call_proc()
{
    long x1 = 1;    // 存在栈上，因为需要取地址
    int x2 = 2;
    short x3 = 3;
    char x4 = 4;
    proc(x1, &x1, x2, &x2, x3, &x3, x4, &x4);   // x4和&x4需要存放到栈中
    return (x1+x2)*(x3+x4);
}
```

![函数栈帧举例.png](深入理解计算机系统/函数栈帧举例.png)

- 变长栈帧

现在的编译器能够预先确定需要为栈帧分配多少空间，但对于有些函数，需要的局部存储是变长的，此时为了管理变长栈帧，x86-64使用寄存器%rbp作为帧指针。只需要将%rbp作为栈使用寄存器，保存之前的状态值，并设置当前栈顶指针。

```c
long vframe(long n, long idx, long *q)
{
    long i;
    long *p[n]; // 变长
    //...
}

// 汇编%rbp
pushq %rbp
movq %rsp, %rbp
```

## 4. 数据结构的表示

局部的数组、结构体和联合体一定放在栈中。

### 数组

```c
T A[N];
```

数组是在内存中分配一个`sizeof(T)*N字`节的连续区域，数组名`A`是一个指向数组开头的指针。数组引用`A[i]`等同于表达式`*(A+i)`。假设数组起始地址为`xa`，T为`int`，对数组需要有如下认知：

表达式 | 类型 | 值
---|---|---
A | int* | xa
A[0] | int | M[xa]
&A[i] | int* | xa + 4i
A[i] | int | M[xa + 4i]
&A[i] - A | long | i

多维数组在内存中按照“行优先”的顺序排列。对于多维数组：

```c
int A[5][3]
// 等价于
typedef int row3_t[3];
row3_t A[5];
```
### 结构和联合

两者都是创建一个数据类型，将不同类型的对象居合到一个对象中。用名字来引用各个组成部分。

当我们知道一个数据结构中两个不同字段的使用是互斥的，可以将这两个声明为联合的一部分，而不是结构的一部分，这样可以减少分配内存空间的总量。

数据对齐。计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是2、4或8的整数倍，这种对齐限制可以简化处理器和内存系统之间接口的硬件设计。否则一个数据可能需要多次访问内存获取数据。

对齐原则：任何K字节的基本对象的地址必须是K的倍数。\
有效省内存方式：按照大小降序排列元素。

![对齐.png](深入理解计算机系统/对齐.png)

## 5. 运行时内存异常

数组引用不进行任何边界检查，当函数调用过程中，数组越界写入导致栈中局部变化、保存的寄存器值甚至返回地址被破坏，导致缓冲区溢出，程序崩溃。

库函数`gets()`、`strcpy()`、`strcat()`和`sprintf()`都是不安全的函数，不会判断字符串空间是否足够。

缓冲区溢出也被黑客用来攻击计算机。常见的保护措施有：
1. 栈随机化：每次程序运行，栈的位置都有变化。可以将栈起始地址设定在一个范围内，程序每次随机运行在某个地址
2. 检测何时栈被破坏，增加栈保护者机制，在栈帧中任何局部缓冲区和栈状态之间存储一个随机产生的特殊的值，哨兵值(guard value)，检测该值是否被某个操作改变，发现改变，异常终止程序
3. 限制内存的读、写和可执行权限，限制哪部分内存可存储可执行代码

