---
title: "07_链接"
date: 2023-07-04T22:19:20+08:00
draft: true
tags: ["深入理解计算机系统"]
categories: ["读书笔记"]
---


## 0. 前言

看这章前建议先阅读《程序员的自我修养》，里面有很多关于库与链接的描述。因为《深入理解计算机系统》是译本，有很多拗口的名称，通过建议书籍，你可以更方便的理解书中描述的过程。

这里先列出一些关于链接的基础知识，简化后续章节的描述。

### 0.1 目标文件

目标文件有三种：

- 可重定位目标文件：可用于链接生成可执行文件，如`.o`文件
- 可执行目标文件：可被直接复制到内存中执行，如`a.out`
- 共享目标文件：一种特殊类型的可重定位目标文件，可在加载或运行时被动态的加载进内存并链接，如`.so`

经过编译器和汇编器后生成可重定位目标文件，经过链接器生成可执行目标文件。目标文件是二进制文件，

### 0.2 典型的ELF可重定位目标文件

![典型的ELF可重定位目标文件.png](深入理解计算机系统/典型的ELF可重定位目标文件.png)

`.symtab`符号表中记录了符号的如下内容：
- `name`，在字符串表中的偏移
- `type`，变量/函数
- `binding`，static/非static
- `section`，符号所在的段，对于上图中的代码与数据的段，用数字表示；此外还有3种特殊的伪节：`ABS`(不该被重定位的符号)、`UND`(未定义的符号)、`COM`(未初始化的全局符号)。只有可重定位文件中才有伪节，可执行文件中没有
- `value`，距符号所在节起始位置的偏移，对于`COM`符号，表示对齐要求。在可执行文件中，为绝对地址（虚拟地址）
- `size`，符号的大小，对于`COM`符号，表示最小的大小。

![c中的变量与函数.png](深入理解计算机系统/c中的变量与函数.png)

对于COM块，是针对弱符号的，有如下规则：
1. 出现多个同名强符号，编译报错；
2. 出现一个强符号，多个弱符号，以强符号为主；
3. 出现多个弱符号，以内存最大的为主。

### 0.3 查看ELF命令

[使用readelf和objdump查看ELF常见段](https://blog.csdn.net/qq_42570601/article/details/127360128)
- `readelf -h`，查看ELF头
- `readelf -s`、`objdump -t`、`nm`，查看符号表。
- `readelf -S` 、`objdump -h`，查看段表结构
- `objdump -d`，查看反汇编代码，`objdump -dx`可以看到重定位入口地址计算类型
- `readelf -d`，查看依赖的动态库

### 0.4 链接

代码经预处理器、编译器和汇编器之后生成可重定位目标文件，要想生成最终的可执行文件，需要经过链接器。链接可分为静态链接和动态链接。

链接最重要的是符号解析和重定位。
- 符号解析：确定全局符号唯一的定义
- 重定位：确定每个符号最终的内存地址并修改堆这些符号的引用

## 1. 静态链接

### 生成静态库

`.a`文件是一组`.o`文件的集合。使用`ar`工具做此打包操作。

[Linux 合并多个.a 静态库文件](https://blog.csdn.net/humadivinity/article/details/107390085)

```shell
# 1. 将多个*.o打包成libtarget.a
ar rcs libtarget.a a.o b.o c.o

# 2. 将多个.a合成一个.a
#（1）先编写一个mri 脚本，如newLib.mri,内容如下
 
create newLib.a
 
addlib oldlib1.a 
addlib oldlib2.a 
addlib oldlib3.a 
 
save
end
 
#(2)执行该脚本
ar -M <./newLib.mri
```

### 静态链接过程

![链接过程.png](深入理解计算机系统/链接过程.png)

链接器按照命令行中参数从左只有进行链接操作。链接器维护可重定位文件集合E，未解析符号集合U和已定位符号集合D。链接初始状态，E、U、D为空。

- 地址与空间分配：确定集合E后，便可根据可重定位文件各段属性合并文件，确定虚拟地址。
- 重定位：根据.rel中的重定位入口，修正对应值与地址。

鉴于链接过程中从左只有遍历文件，未定义符号只能由后续.o中的符号定义来补全，所以顺序也会影响链接成功与否。

### 加载

![可执行文件与加载.png](深入理解计算机系统/可执行文件与加载.png)

加载：将可执行文件复制到内存并运行的过程。\
内核内存是操作系统驻留在内存中的部分，是内核中代码和数据的保留。

## 2. 动态链接

为解决同样的库代码在多个不用进程中被包含，消耗内存资源这一问题，产生了共享库与动态链接。

动态链接：在运行和加载时，可以加载共享库到任意内存地址，并和一个在内存中的程序连接起来的过程。

### 共享库链接过程

与位置无关的共享库，使用`-fPIC`编译选项，使得共享库代码在内存中可只存在一份代码，当然数据还是各个进程中存有一份。

共享库的基本思想：在创建可执行文件时，静态执行一些链接，复制一些重定位和符号表信息，待到程序加载时，动态完成链接过程。

![共享库链接过程.png](深入理解计算机系统/共享库链接过程.png)

为了实现上述目标，采用了**GOT**(global offset table)，数据段的一部分，全局偏移量表和**PLT**(procedure linkage table)，过程链接表，代码段的一部分。两者均为数组结构。

- 共享对象内部的函数调用和静态全局变量引用通过相对寻址来编译；
- 共享对象中对全局变量（内部定义和外部定义）的引用，使用GOT表，进行间接引用
- 程序访问共享对象定义的函数，为了提高性能，采用延迟绑定（lazy binding），将过程地址的绑定推迟到第一次调用该过程时。通过PLT表，再增加一次间接调用。即过程调用->PLT->GOT->真正地址。

### 显示加载共享库

编译时需要加`-ldl`。

`dlopen()`、`dlsym()`、`dlclose()`可在程序运行过程中，动态加载与卸载共享库。`dlerror()`查看错误信息。

## 3. 库打桩机制

所谓库打桩，就是允许截获对共享库函数的调用，取而代之执行自己的代码。一般可以做调试使用，也可完全改变其实现。打桩可以发生在编译时、链接时、运行时。

- 编译时，通过预处理器打桩

```c
#define malloc(size)    mymalloc(size)
#define free(ptr)       myfree(ptr)
```

- 链接时

通过`--wrap func`告知链接器，将对符号`func`的引用解析成`__wrap_func`，对`__real_func`的引用解析成`func`。

```shell
gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o
```

```c
void __wrap_malloc(size_t size)
{
    void *ptr = __real_malloc(size);    // 本质上调用malloc(size)
}
```

- 运行时

在程序运行前，通过`LD_PRELOAD`指定库的搜索顺序。

```shell
$ LD_PRELOAD=“./mymalloc.so”
$ ./intr
```