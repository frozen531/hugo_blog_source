---
title: "05_操作符和表达式"
date: 2023-03-05T21:22:06+08:00
draft: true
tags: ["C和指针"]
categories: ["读书笔记"]
---

# 操作符和表达式

## 1. 操作符

### 🔰1.0 操作符优先级

- <font color=blue>**非真正意义运算符 > 单目运算符 > 算 > 移 > 关 > 位 > 逻 > 赋 > 三**</font>
- 结合性只用于表达式中出现两个以上相同优先级的操作符的情况，且相同优先级的操作符，结合性也相同
- 专家认为，除了乘除和加减的优先级，其他涉及其他操作符时一律加上括号

#### 1.0.1 非真正意义上的运算符

- ```()```：聚组作用
- ```()```：函数调用
- ```[]```：下标运算
- ```., ->```：成员操作符

运算符 | 结合性
--- | ---
```() () [] . ->``` | 自左向右

#### 1.0.2 单目运算符

- ```++, --```：后缀
- ```++, --```：前缀
- ```*```：间接访问
- ```&```：取地址

运算符 | 结合性
--- | ---
```++ -- ! ~ - (type) * & sizeof``` | 自右向左

#### 1.0.3 算术运算符

运算符 | 结合性
--- | ---
```* / %``` | 自左向右
```+ -``` | 自左向右

#### 1.0.4 移位运算符

运算符 | 结合性
--- | ---
```<< >>``` | 自左向右

#### 1.0.5 关系运算符

运算符 | 结合性
--- | ---
```< <= > >=``` | 自左向右
```== !=``` | 自左向右

#### 1.0.6 位运算符

运算符 | 结合性
--- | ---
```&``` | 自左向右
```^``` | 自左向右
```\|``` | 自左向右

#### 1.0.7 逻辑运算符

运算符 | 结合性
--- | ---
```&&``` | 自左向右
```\|\|``` | 自左向右

#### 1.0.8 赋值运算符

运算符 | 结合性
--- | ---
```=``` | 自右向左
复合赋值 | 自右向左

#### 1.0.9 三目运算符

运算符 | 结合性
--- | ---
```? :``` | 自右向左

#### 1.0.10 逗号运算符

- 所有运算符中优先级最低

### 🔰1.1 算术操作符

```c
+   -    *   /   %
```

- 除了```%```外，其他既可用于整数类型也可用于浮点类型。```%```接收整型操作数
- ```/```的两个操作数都是整数时，执行整数除法；其他情况执行浮点除法

### 🔰1.2 移位操作符

```c
<<   >>
```

- 对于左移和逻辑右移，移出的位舍弃，空出来的补```0```
- 对于算术右移，根据符号位填补空出位，正数填```0```，负数填```1```
- 对于无符号数，一律采用逻辑移位；有符号数的右移取决于编译器，因此如果**代码中使用了有符号数的右移操作，就不可移植**

### 🔰1.3 位操作符

```c
&(与AND)    |(或OR)    ^(异或XOR)
```

- ```^```两个位相同结果为```0```，不同为```1```

### 🔰1.4 赋值操作符

#### =

```c
=
```

- 赋值操作符结合性从右到左

```c
a = x = y + 3;

// 等价于
a = (x = y + 3);
```

- 说```a```和```x```被赋予了相同的值是不正确的。如果```x```为```char```型，则```y+3```的值会被截去一段，那么a被赋予的值是被截断后的值

#### 复合赋值符

```c
+=      -=      *=      /=      %=
<<=     >>=     &=      ^=      |=
```

- 使用复合赋值符使程序更易于维护

### 🔰1.5 单目操作符

```c
!（逻辑取反）      ++      -      &（取地址）      sizeof（判断操作数长度）
~（取补码）      --      +      *（间接访问操作符）      (类型)（强制类型转换）
```

- sizeof操作符判断操作数的类型长度，结果以字节为单位
> 1. 操作数为表达式：
> - 单个变量，```sizeof x```或```sizeof (x)```；
> - 为表达式时，判断表达式长度并不会对表达式进行求值，```sizeof(a = b + 1)```
> 2. 操作数为类型名。```sizeof (int)```
> 3. 操作数为数组名，返回该数组的长度

- (类型)为强制类型转换符
> - 强制类型转黄放在表达式前面只会改变表达式的第1个项目的类型```long a = (long)b + c;```

- ```++```，```--```只能操作变量

### 🔰1.6 关系操作符

```c
>    >=     <    <=     !=       ==
```

- C中没有布尔类型，关系运算符的操作数用```0```表示假，非```0```表示真
- 通过关系运算符得到的结果真为```1```，假为```0```

### 🔰1.7 逻辑操作符

```c
&&    || 
```

- 短路求值
> ```&&```：左操作数为假时，右操作数不再求值
> ```||```：左操作数为真时，右操作数不再求值

### 🔰1.8 条件操作符

```c
expression1 ? expression2 : expression3
```

### 🔰1.9 逗号操作符

```c
expression1, expression2, expression3...
```

- 上述表达式从左向右依次运算
- 逗号操作符的结果为最后一个表达式的值

### 🔰1.10 下标引用、函数调用和结构成员

#### 下标引用[]

```c
array[下标] // 等价于
*(array + 下标)
```

- 接受两个操作符：一个数组名，一个索引值
- 下标引用实际上是通过```*(array + 下标)```实现

#### 函数调用()

- 接受一个或多个参数：第一个为函数名，剩余为函数的参数
- 可以以表达式作为函数名

#### 结构成员.和->

```c
s.a  // s为结构变量
s->a // s为指向结构变量的指针
```

### 🔰1.11 sizeof

- 计算所占内存的多少
- 操作数类型：
> - 类型名：需要加上括号
> - 变量：不必加括号
- ```sizeof(数组)```：数组所占的内存空间大小```=N*sizeof(type)```

## 2. 布尔值

- C中没有布尔值，而使用整数代替，规则是：**0为假，非0为真**
- 应避免混合使用整型值和布尔值，如下```flag```必为整型，但是它的值不一定局限于```0```和```1```，则```if (flag == TRUE){}```就不等价

```c
#define FALSE 0
#define TRUE  1
...
if (flag == FALSE){}
if (flag == TRUE){}
```

- 如果一个变量用于表示布尔值，则应该把它的值始终设置为```0```或```1```，并不与特定的值进行比较判断是否为真

```c
flag = value >= 0;

if (!flag){}
if (flag){}
```

## 3. 左值和右值

- 左值<font color="blue">**标识了一个可以存储结果值的地点，该地址在编译时便可知，存储于符号表中**</font>，可以位于```=```左边或右边
- 右值<font color="blue">**只提供一个值，直到运行时才知道**</font>，这个值的结果不能预测存储在哪里

## 4. 表达式求值

- 整型算术运算的表达式在计算时至少以整型类型的精度进行，即“整形提升”
- 下面的算术转换，a * b可能超出int范围，值会溢出，c为错误的值，所以需要修改为```long c = (long)a * b;```

```c
int a = 5000;
int b = 25;
long c = a * b; // => long c = (long)a * b;
```

- 操作符
> 表达式求值顺序由操作符优先级、结合性和操作符是否控制执行顺序决定
> > 1. 相邻操作符的执行顺序由优先级决定
> > 2. 优先级相同时，由结合性决定
> > 3. 编译器自由决定对表达式的求值顺序，只要遵守```,```，```&&```，```||```和```?:```操作符施加顺序限制
- 各操作数的计算顺序是不确定的，它的目的是使编译器选区最合适的顺序产生最快的代码
```c
a * b + c * d + e * f

// 1. 求值优先级肯定*高于+，*在它相邻的+之前执行
// 2. 加法的结合性要求从左到右
// 3. 乘法的计算顺序不一定，执行顺序可以如下：
// a * b
// c * d
// (a * b) + (c * d)
// e * f
// (a * b) + (c * d) + (e * f)

// 或

// c * d
// e * f
// a * b
// (a * b) + (c * d)
// (a * b) + (c * d) + (e * f)
```













