---
title: "03_数据"
date: 2023-03-05T21:22:04+08:00
draft: true
tags: ["C和指针"]
categories: ["读书笔记"]
---

# 数据

## 1. 基本数据类型

在C语言中仅有4类基本数据类型：
- 整型
- 浮点型
- 指针
- 聚合类型（如数组和结构等）

其他类型均由这4类组合派生而来。

### 🏳️‍🌈1.1 整型

- 整型家族包括：字符、短整型、整型和长整形，并分为有符号和无符号两个版本
- 综合上述，共9种不同类型：

字符 | 短整型 | 整型 | 长整形
--- | --- | --- | --- 
```char```, ```signed char```, ```unsigned char``` |```short int```, ```unsigned short int``` | ```int```, ```unsigned int``` | ```long int```, ```unsigned long int```
3 | 2 | 2 | 2

- ```signed```关键字一般只用于```char```，其他类型在缺省情况下都是有符号数
- 整型值相互间大小的规则：**长整形至少应该和整型一样长，而整型至少应该和短整型一样长**
- 在头文件```limits.h```中指明了不同整数类型的特点：位数、范围等，范围如下表：

类型 | signed最小值 | signed最大值 | unsigned最大值
--- | --- | --- | ---
字符 | SCHAR_MIN | SCHAR_MAX | UCHAR_MAX
短整型 | SHRT_MIN | SHRT_MAX | USHRT_MAX
整型 | INT_MIN | INT_MAX | UINT_MAX
长整型 | LONG_MIN | LONG_MAX | ULONG_MAX

#### 1.1.1 整型字面值

- 整型字面值是哪种类型取决于其书写方式，通常十进制使用为多，加```L```或```l```表示长整形，加```U```或```u```表示```unsigned```

十进制 | 八进制 | 十六进制
--- | --- | ---
```123``` | 以```0```开头 | 以```0x```开头

#### 1.1.2 字符常量

- 类型总是```int```，不能添加```unsigned```或```long```
- 使用单引号包围单个字符，如：```'M'```, ```'\n'```, ```'\377'```


#### 1.1.3 枚举类型

- 关键字```enum```

```c
// 枚举类型声明
enum Direction{ UP, DOWN};

// 枚举变量声明
Direction d1, d2;

// 上面也可以统一写为
enum Direction{ UP, DOWN} d1, d2;
```

- 枚举变量以整数形式存储，默认```UP=0```，也可以指定特定的整型值，其后没有指明的会依次递增，如```Thursday=21```...

```c
// 枚举类型声明
enum Day{ Monday = 5, Tuesday = 7, Wednesday = 20, Thursday, Friday, Saturday, Sunday };
```

- 很少有事是只能靠枚举而不能使用```define```来解决的
- 枚举相比```define```的优点：
> ```#define```定义的名字在编译时丢弃，而枚举名字则一直在调试器中可见，可以在调试代码时使用它们

### 🏳️‍🌈1.2 浮点型

- 浮点数家族包括```float```，```double```，```long double```。
- 头文件```float.h```中定义了```FLT_MAX```，```DBL_MAX```和```LDBL_MAX```，对应```FLT_MIN```，```DBL_MIN```和```LDBL_MIN```
- 浮点数字面值默认为```double```，加```L```或```l```为```long double```，加```F```或```f```为```float```

### 🏳️‍🌈1.3 指针

- 指针变量存放内存地址的值
- 相当于房子的门牌号

## 2. typedef 和 define

### 🏳️‍🌈2.1 typedef

- ```typedef```为各种数据类型创建别名，而不是创建新的数据类型
- ```typedef```声明格式与变量声明（参见```13-2.2.1```和```13-2.2.2```）完全一样，只不过加上关键字```typedef```，向你提醒它的实质

```c
// 变量声明
char *p;
// typedef声明
typedef char *ptr_to_char;

char *p;
// 等价于
ptr_to_char p;
```

- 为结构创建别名，具体参见```10-1.1```

#### 2.1.1 注意

- 不要在一个```typedef```中放入几个声明器

```c
typedef int *ptr, (*fun)(), arr[5];
```

- 不要把typedef嵌到声明的中间部分

```c
unsigned const long typedef int volatile *k;
```

- 不要为了方便对结构使用```typedef```
> 对结构使用```typedef```顶多可以少些一个```struct```关键字，但是```struct```关键字可以起提示作用，使代码更为清晰


#### 2.1.2 用途

➰ 1. 应用于数组、结构、指针及函数的组合类型 <br>
➰ 2. 为强制类型转换提供一个简单的名字

```c
typedef int (*ptr_to_int_fun)(void);
char *p; // 指针原先指向的是char类型变量
...
.. = (ptr_to_int_fun) p; // 强制类型转为指向函数的指针
```

### 🏳️‍🌈2.2 define

具体参见```14-3.1```

### 🏳️‍🌈2.3 typedef 和 define区别

➰ 1. 可以用其他类型说明符对宏类型名进行扩展，而```typedef```所定义的类型名却不可以

```c
#define d_int int
unsigned d_int a ; // 正确

typedef int t_int;
unsigned t_int b ; // 非法
```

➰ 2. 在连续几个变量的声明中，用```typedef```可以保证声明中所有变量均为同种类型，而用```define```定义的类型则无法保证

```c
#define ptr_to_char char*
ptr_to_char p, q;

// 预处理器将其替换如下：
char* p, q;
```

> ```define```也可以定义新类型名，但是不能正确处理指针类型。如下：p被声明为指针```char *```，但是却被声明为字符```char```

## 3. const

- <font color=blue>**```const```并不能将变量变为常量**</font>
- ```const```表示该符号不能被赋值，它的值对于这个符号来说是只读的
- 但是不能保证通过其他方法修改这个值。例如函数传参中加入```const```只是说在该函数中不能修改对应值，但在函数外其他位置则不保证其值不会被修改
- ```const```最有用之处是限定函数参数

### 🏳️‍🌈3.1 修饰变量
- const修饰的变量为常量：
> 1. 变量需要在声明时初始化；
> 2. const类型的形参在函数调用时赋值

```c
int const a;
// 等价
const int a;
```

- 对于创建名字常量，使用```define```会比```const```更好。因为允许使用字面值常量的地方都可以使用前者，比如数组的长度；```const```只能用于使用变量的地方

```c
#define MAX 50
int a[MAX];

const int max = 50;
int a[max]; // 错误
```




### 🏳️‍🌈3.2 修饰指针
- 从右至左分析
- int * const p;
> p是一个指针常量，指向一个整型变量

- const int *p;
> p是一个指针变量，指向一个int常量

- const int * const p;
> p是一个指针常量，指向一个整型常量

## 4. 声明与定义 

C语言中变量只能有一次定义，可以有多次声明

- 定义：特殊的声明，为变量分配内存
- 声明：普通的声明，用于描述在其他地方创建的对象.
> 这里只是告知编译器，对象的类型和名字。<br>
> 由于声明中不分配内存，所以如果是数组，可以不提供数组长度信息，只要保证与要引用的数组声明类型和变量名一致即可，关键字为```extern```

```c
// 声明
extern int arr[];

// 别处的定义
int arr[100];
```


## 5. 作用域、链接属性和存储类型

- 作用域：文件作用域，函数作用域，代码块作用域和原型作用域
- 链接属性：外部（external），内部（internal）和无（none）
> 1. ```external```指标识符不论声明多少次，位于几个源文件都表示同一个实体
> > - 函数和具有文件作用域的变量，链接属性为```external```
> 2. ```internal```指同一源文件中多有声明中都指向同一个实体
> > - ```static```关键字可以将```external```链接属性的变量转变为```internal```属性
> 3. ```none```指标识符的多个声明都被当做独立不同的实体
> > - 局部变量的链接属性为```none```
- 存储类型是指存储变量值的内存类型：普通内存，运行时堆栈和硬件寄存器
> ```register```关键字声明局部变量，提示编译器将变量存储与寄存器而非内存中，不过最终是否将其存放于寄存器又编译器决定

### 🏳️‍🌈4.1 extern

- 作用：
> 1. 用于变量声明使用，<font color = "gree">**引用别处定义的变量，用于提示的其实是一个内存地址**</font>，所以对于数组来说并不用指明元素个数

```c
// 下面两个声明等价
extern int arr[];
extern int arr[100];
```

> 2. 为**局部**标识符指定```external```链接属性，这样就可以访问在其他任何位置定义的这个实体

### 🏳️‍🌈4.2 static

- 用于变量声明使用
- 作用：
> 1. 修饰具有```external```链接属性的声明，```static```可以使它的链接属性变为internal，上述转换包括全局变量和函数

```c
static int a; // 全局变量
static int f(int b); // 函数
```

> 2. 修饰局部变量，使其转变为静态变量，存放于静态存储区

### 🏳️‍🌈4.3 总结

变量类型 | 声明的位置 | 是否存于堆栈 | 作用域 | 链接属性 | 如果声明为static
---|---|---|---|---|---
全局 | 所有代码块之外 | 否 | 从声明处至文件尾 | external | 变为internal属性，不允许其他源文件访问
局部 | 代码块和函数内 | 是 | 代码块和函数内 | none | 变量不存储于堆栈中，它的值在整个执行期一直保持
形式参数 | 函数形参 | 是 | 整个函数内 | none | 不允许
















