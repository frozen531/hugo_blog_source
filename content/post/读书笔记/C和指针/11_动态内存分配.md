---
title: "11_动态内存分配"
date: 2023-03-05T21:22:11+08:00
draft: true
tags: ["C和指针"]
categories: ["读书笔记"]
---

# 动态内存分配

## 1. 为什么进行动态内存分配

- 以数组来说，很多时候我们并不知道实际数组中存放多少元素，所以会指定一个常量来提前说明数组的长度（编译时），但是这样很多情况下会造成内存浪费
- 动态内存分配可以在运行时分配内存

## 2. 动态内存分配

### 🎨2.1 动态内存分配的内存空间从哪里来

- 动态内存分配的维护一个可用的<font color = #D87093>**内存池**</font>
- 头文件```#include <stdlib.h>```

### 🎨2.2 malloc和free

#### 2.2.1 malloc

```c
void *malloc(size_t size);
```

- ```malloc```函数从内存池中申请一块相应大小的内存，并返回指向该内存的指针
- 每次都应当对返回值进行检测，当系统无法为```malloc```提供相应多的内存时，返回```NULL```

```c
int *p = malloc(100);
if(p == NULL)
{
    printf("Out of memory!\n");
    exit(1);
}
```

- ```void *```类型的指针可以转换为任何类型
- ```malloc```返回的内存起始位置始终满足边界对齐的要求
- 为提高代码的可移植性，malloc可以按照下面的方式计算所需内存大小

```c
p = malloc(25 * sizeof(int)); 
```

#### 2.2.2 free

```c
void free(void *pointer);
```
- ```free```传入的指针是有```malloc```返回的指针
- 当传入参数为```NULL```，不会有任何效果

### 🎨2.3 calloc和realloc

#### 2.3.1 calloc

```c
void *calloc(size_t num_elements, size_t element_size);
```

- 与```malloc```的区别
> ```calloc```在返回指针之前把它初始化为```0```

#### 2.3.2 realloc

```c
void realloc(void *ptr, size_t new_size);
```

- 用于修改原先已经分配的内存块的大小，可以扩大或缩小
> 1. 扩大：新增加的内存添加到原有内存块的后面；若原先的内存块无法改变大小，则会重新申请另一块正确大小的内存，并将原有的内容拷贝过来，因此使用```realloc```后，要改用```realloc```返回的指针
> 2. 缩小：内存块尾部内存被释放

### 🎨2.4 常见的动态内存错误

- 不能对```NULL```解引用，所以要事先判断
- 当多个指针指向同一块内存时，要确保所有指针都不使用该内存才能销毁内存
- 试图释放一块动态内存中的一部分内存
- 对分配的内存操作越界
- 试图释放非动态分配的内存
- 忘记对动态分配的内存进行释放，严重会造成**内存泄漏**
